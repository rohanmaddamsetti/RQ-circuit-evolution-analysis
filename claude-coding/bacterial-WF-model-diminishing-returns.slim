/* bacterial-WF-model-diminishing-returns.slim 
by Rohan Maddamsetti
last updated 02/02/2026 to work in SLiM 5.

Wright-Fisher model of an idealized haploid bacterial genome
 with diminishing-returns epistasis.

 Diminishing returns follows the model of Wiser et al. (2013,
 Science 342: 1364-1367) as implemented in the STEPS simulator
 (Lake, Matson, & Lenski 2025).

 When beneficial mutations accumulate in a lineage, the distribution
  of fitness effects (DFE) for new beneficial mutations narrows,
 causing the rate of adaptation to slow over time.

 Key equation: alpha_{n+1} = alpha_n * (1 + g * s_{n+1})
 where alpha = 1/(mean of beneficial DFE),
       g = strength of diminishing returns epistasis,
       s_{n+1} = selection coefficient of the newest mutation.

 Fitness is multiplicative: W = product(1 + s_i) for all mutations i.

*/

initialize()
{
	if (exists("slimgui")) // if running with the SLiM GUI
	{
		defineConstant("Ne", 1e4); // effective population size
		defineConstant("mu", 1e-9); // mutation rate per bp per generation.
		defineConstant("numgens", 50000);
		defineConstant("outfile", "SLiM-output-DR.csv");
		defineConstant("subst_outfile", "SLiM-substitutions-DR.csv");
	}

	// LTEE parameters:
	//Genome size = 4.62e6 base pairs
	//Ne = 3.3e7 cells
	//initial sb in LTEE = 0.01587 (Izutzu et al. 2021)
	// mu = 8.9e-11 per base-pair per cell per generation,
	// so mu = 0.00041118 = 4.11e-4 per cell per generation.

	// STEPS simulation parameters (Izutzu et al. 2021):
	// final population size, Nf = 5 x 10^8 cells;
	// beneficial mutation rate, mu_B = 1.7 x 10^-6 per cell per generation
	// mean effect size of beneficial mutations in the ancestor,
	// s = 0.01587;
	// and strength of diminishing-returns epistasis, g = 6.0217.

	// ---- Diminishing-returns epistasis parameters ----
	// Initial mean beneficial selection coefficient in the ancestor.
	defineConstant("initial_mean_s", 0.01587);
	// Strength of diminishing-returns epistasis.
	defineConstant("g_epistasis", 6.0217);
	// alpha_0 = inverse of the initial mean beneficial effect.
	defineConstant("alpha_0", 1.0 / initial_mean_s);

	// ---- Mutation types ----
	// m1: beneficial mutations drawn from an exponential distribution.
	// The mutation() callback below overrides each new mutation's
	// selection coefficient to implement diminishing returns.
	initializeMutationType("m1", 1.0, "e", initial_mean_s);
	// m2: strongly deleterious: 30% fitness defect (Robert et al. 2018)
	initializeMutationType("m2", 1.0, "f", -0.3);
	// m3: completely neutral
	initializeMutationType("m3", 1.0, "f", 0.0);
	// m4: nearly-neutral background: use -1*Beta(alpha=0.0074,beta=2.4),
	// based on Lydia Robert et al. (2018) in Science.
	// multiply by -1 since most mutations are weakly deleterious.
	initializeMutationType("m4", 1.0, "s", "return -1*rbeta(1,0.0074,2.4);");

	// CRITICAL: prevent SLiM from removing fixed m1 mutations.
	// Fixed beneficial mutations must remain in haplosomes so
	// the mutation() callback can include them when computing
	// alpha for diminishing-returns epistasis.
	m1.convertToSubstitution = F;
	m2.convertToSubstitution = F;
	m3.convertToSubstitution = F;
	m4.convertToSubstitution = F;

	m1.color = "green";
	m1.colorSubstitution = "green";
	m2.color = "red";
	m2.colorSubstitution = "red";
	m3.color = "yellow";
	m3.colorSubstitution = "yellow";
	m4.color = "orange";
	m4.colorSubstitution = "orange";

	// ---- Genomic DFE by region ----
	// Module 1: 10% of mutations are beneficial.
	initializeGenomicElementType("g1", c(m1,m4), c(0.1, 0.9));
	// Module 2: 40% of mutations are strongly deleterious.
	initializeGenomicElementType("g2", c(m2,m4), c(0.4, 0.6));
	// Module 3: 100% of mutations are completely neutral.
	initializeGenomicElementType("g3", m3, 1.0);
	// Module 4: the rest of the genome has the DFE from Robert et al. (2018).
	initializeGenomicElementType("g4", m4, 1.0);

	g1.color = "green";
	g2.color = "red";
	g3.color = "yellow";
	g4.color = "orange";

	// Haploid genome of 4 million base pairs.
	initializeChromosome(1, 4000000, type="H");
	initializeGenomicElement(g1, 0, 99999);
	initializeGenomicElement(g2, 100000, 199999);
	initializeGenomicElement(g3, 200000, 299999);
	initializeGenomicElement(g4, 300000, 3999999);

	// LTEE point mutation rates per bp per genome per generation:
	// Nonmutator ~ 1e-10;
	// Hypermutator ~ 1e-8 (100x).
	initializeMutationRate(mu);

	// asexual bacterial evolution.
	initializeRecombinationRate(0.0);
}


// ---- Diminishing-returns epistasis callback ----
// When a new beneficial mutation (m1) arises, its selection coefficient
// is redrawn from an exponential DFE whose mean depends on the
// genetic background of the parent.
//
// 1. Compute alpha from all existing beneficial mutations on the
//    parental haplosome: alpha = alpha_0 * product(1 + g * s_i).
// 2. Optionally adjust alpha for deleterious mutations using
//    STEPS equation 8: g* = g / (-g + |s| + 1).
// 3. Draw new s from Exp(mean = 1/alpha) and assign it.
//
// As alpha increases, the mean beneficial effect (1/alpha) decreases,
// producing diminishing returns over the course of adaptation.
mutation(m1)
{
	// Start with the initial alpha.
	alpha = alpha_0;

	// --- Beneficial mutations increase alpha (narrow the DFE) ---
	// 'haplosome' is the parental haplosome being copied.
	existing_ben = haplosome.mutationsOfType(m1);
	for (m in existing_ben)
		alpha = alpha * (1.0 + g_epistasis * m.selectionCoeff);

	// --- Deleterious mutations decrease alpha (widen the DFE) ---
	// This uses the complementary epistasis model from STEPS:
	// g* = g / (-g + |s| + 1)
	// For typical g >> |s|, g* is negative, so deleterious mutations
	// decrease alpha, reflecting that less-fit organisms have more
	// room for beneficial improvement.
	// Only m2 (strongly deleterious) is included; m4 mutations are
	// near-neutral and have negligible effect on alpha.
	existing_del = haplosome.mutationsOfType(m2);
	for (m in existing_del)
	{
		s_mag = abs(m.selectionCoeff);
		denom = -g_epistasis + s_mag + 1.0;
		if (abs(denom) > 1e-10) // guard against division by zero
		{
			g_star = g_epistasis / denom;
			factor = 1.0 + g_star * s_mag;
			if (factor > 0.0) // guard against non-positive factor
				alpha = alpha * factor;
		}
	}

	// Ensure alpha is positive.
	if (alpha <= 0.0)
		alpha = alpha_0;

	// Draw new selection coefficient from Exp(mean = 1/alpha).
	// In Eidos, rexp() takes the mean parameter, not the rate.
	new_mean_s = 1.0 / alpha;
	new_s = rexp(1, new_mean_s);

	// Override the mutation's selection coefficient.
	mut.setSelectionCoeff(new_s);

	return T;
}


// At the first generation, create a clonal population.
1 early()
{
	sim.addSubpop("p1", asInteger(Ne));
	p1.setCloningRate(1.0); // Essential for bacteria.

	// if the outfile already exists,
	// then delete it so we don't append
	// new run data to old run data.
	if (fileExists(outfile))
		deleteFile(outfile);

	// Write header line.
	writeFile(outfile, "generation,mean_fitness,max_fitness");

	// Initialize substitutions output file.
	if (fileExists(subst_outfile))
		deleteFile(subst_outfile);

	// Write header for substitutions file.
	writeFile(subst_outfile, "fixation_gen,mutation_id,mutation_type,position,selection_coeff,origin_gen");

	// Initialize a vector to track mutation IDs that have already been recorded as fixed.
	sim.setValue("recorded_fixed_ids", integer(0));
}


// max number of generations is 10,000.
// cached fitnesses should be accessed at the first() or early() stage.
1:numgens early()
{
	// Print progress every 100 generations.
	if (sim.cycle % 100 == 0 | sim.cycle == 1)
	{
		fitnesses = p1.cachedFitness(NULL);
		mean_w = mean(fitnesses);
		max_w = max(fitnesses);

		cat("Generation: " + sim.cycle +
			" | Mean W: " + format("%.6f", mean_w) +
			" | Max W: " + format("%.6f", max_w) + "\n");

		// Write data to output file.
		line = sim.cycle + "," + mean_w + "," + max_w;
		writeFile(outfile, line, append=T);
	}

	// ---- Track fixed substitutions ----
	// Check for newly fixed mutations and record them.
	// A mutation is fixed when its frequency = 1.0 in the population.
	recorded_ids = sim.getValue("recorded_fixed_ids");

	// Get all mutations in the population and their frequencies.
	all_muts = sim.mutations;
	if (size(all_muts) > 0)
	{
		freqs = sim.mutationFrequencies(p1, all_muts);

		// Find mutations that are fixed (frequency == 1.0).
		fixed_indices = which(freqs == 1.0);

		if (size(fixed_indices) > 0)
		{
			fixed_muts = all_muts[fixed_indices];

			for (mut in fixed_muts)
			{
				// Check if this mutation has already been recorded.
				if (sum(recorded_ids == mut.id) == 0)
				{
					// Determine mutation type string.
					if (mut.mutationType == m1)
						mut_type = "m1";
					else if (mut.mutationType == m2)
						mut_type = "m2";
					else if (mut.mutationType == m3)
						mut_type = "m3";
					else
						mut_type = "m4";

					// Write to substitutions file.
					line = sim.cycle + "," + mut.id + "," + mut_type + "," +
						   mut.position + "," + mut.selectionCoeff + "," +
						   mut.originTick;
					writeFile(subst_outfile, line, append=T);

					// Add to recorded IDs.
					recorded_ids = c(recorded_ids, mut.id);
				}
			}

			// Update the stored recorded IDs.
			sim.setValue("recorded_fixed_ids", recorded_ids);
		}
	}

	// run for numgens, where numgens <= 100,000.
	if (sim.cycle == numgens)
		sim.simulationFinished();
}

/* Implementation notes from Claude Code:
How It Works

  Core mechanism: A mutation(m1) callback intercepts every new beneficial mutation at creation time and redraws its selection coefficient from a modified DFE based on the parent's genetic background.

  Step-by-step:
  1. When a new m1 mutation arises, the callback computes alpha from all existing beneficial mutations on the parental haplosome: alpha = alpha_0 * product(1 + g * s_i)
  2. For any existing strongly deleterious mutations (m2), it applies the complementary STEPS formula (equation 8): g* = g / (-g + |s| + 1), which widens the DFE (decreasing alpha) to reflect that less-fit organisms have more room for improvement
  3. A new selection coefficient is drawn from Exp(mean = 1/alpha) using rexp(1, 1.0/alpha)
  4. The mutation's selection coefficient is overridden with mut.setSelectionCoeff(new_s)

  Key design decisions:
  - m1.convertToSubstitution = F keeps fixed beneficial mutations in haplosomes so they're counted in the alpha calculation
  - The haplosome variable in the callback gives direct access to the parent's mutations (the genetic background)
  - SLiM's default multiplicative fitness model (W = product(1 + s_i)) matches STEPS equation 2
  - Numerical guards prevent alpha from going non-positive in edge cases

  Output files:
  - outfile (SLiM-output-DR.csv): logs mean and max fitness every 100 generations
  - subst_outfile (SLiM-substitutions-DR.csv): logs fixed substitutions when they reach 100% frequency

  Substitutions file columns:
  - fixation_gen: generation when the mutation became fixed
  - mutation_id: unique SLiM mutation ID
  - mutation_type: m1 (beneficial), m2 (strongly deleterious), m3 (neutral), m4 (nearly-neutral)
  - position: genomic position (0-based)
  - selection_coeff: selection coefficient of the mutation
  - origin_gen: generation when the mutation first arose

  Parameters (from Izutsu et al. 2021 / STEPS defaults):
  - Initial mean beneficial effect: s = 0.01587
  - Epistasis strength: g = 6.0217
  - All other parameters (genome structure, mutation types, DFE by region) match the base bacterial WF model

*/